# MiniJava
Mini-Java is a subset of Java. MiniJava compiler implement a compiler for the Mini-java
programming language.

# Rules of MiniJava
```
Goal --> Source EOF
Source --> ClassDeclarations MainClass
MainClass --> class Identifier { public static void main() { VarDeclarations Statements}}
ClassDeclarations --> ClassDeclaration ClassDeclarations | lambda
ClassDeclaration --> class Identifier Extension { FieldDeclarations MethodDeclarations }
Extension --> extends Identifier | lambda
FieldDeclarations --> FieldDeclaration FieldDeclarations | lambda
FieldDeclaration --> static Type Identifier ;
VarDeclarations --> VarDeclaration VarDeclarations | lambda
VarDeclaration --> Type Identifier ;
MethodDeclarations --> MethodDeclaration MethodDeclarations | lambda
MethodDeclaration --> public static Type Identifier ( Parameters ) { VarDeclarations Statements return GenExpression ; }
Parameters --> Type Identifier Parameter | lambda
Parameter --> , Type Identifier Parameter | lambda
Type --> boolean | int
Statements --> Statements Statement | lambda
Statement --> { Statements } | if ( GenExpression ) Statement else Statement | while ( GenExpression ) Statement | System.out.println ( GenExpression ) ; | Identifier = GenExpression ;
GenExpression --> Expression | RelExpression
Expression --> Expression + Term | Expression - Term | Term
Term --> Term * Factor | Factor
Factor --> ( Expression ) | Identifier | Identifier . Identifier | Identifier . Identifier ( Arguments ) | true | false | Integer
RelExpression --> RelExpression && RelTerm | RelTerm
RelTerm --> Expression == Expression | Expression < Expression
Arguments --> GenExpression Argument | lambda
Argument --> , GenExpression Argument | lambda
Identifier --> <IDENTIFIER_LITERAL>
Integer --> <INTEGER_LITERAL>
```

<div dir="rtl">
  
# فاز اول

## الگوی strategy 

الگوی طراحی Strategy به ما این امکان را می‌دهد که الگوریتم‌های مختلفی را در یک خانواده تعریف کنیم و بتوانیم بدون تغییر در کلاس‌هایی که از این الگوریتم‌ها استفاده می‌کنند، آن‌ها را با یکدیگر جایگزین کنیم. به عبارت دیگر، این الگو به ما اجازه می‌دهد تا رفتار خاصی را (مثلاً نحوه محاسبه زمان سفر) در کلاس‌های جداگانه پیاده‌سازی کنیم و سپس این رفتارها را به کلاس دیگری (که آن را استفاده می‌کند) تزریق کنیم. در نتیجه وقتی که می‌خواهیم در هنگام محاسبه‌ی هزینه‌ی سفر به جای قطار از اتوبوس استفاده کنیم، کلاسی که با آن‌ها کار می‌کند نیاز به تغییر ندارد.

برای مدیریت تفاوت زمان قطار و اتوبوس از الگوی Strategy استفاده می‌کنیم.


رابط TravelStrategy: این اینترفیس یک متد مشترک calculateTime تعریف می‌کند که در کلاس‌های مختلف به‌صورت متفاوت پیاده‌سازی می‌شود.

 کلاس TrainStrategy: پیاده‌سازی این استراتژی برای محاسبه زمان سفر با قطار است. در اینجا از الگوریتم bfs برای محاسبه‌ی فاصله استفاده می‌شود چون زمان حرکت قطار بین هر دو شهری ثابت است و این هزینه در یک عدد ثابت ضرب می‌شود.
 
 کلاس BusStrategy: این کلاس از دیکسترا برای محاسبه فاصله استفاده می‌کند و زمان سفر بر اساس وزن یال‌ها محاسبه می‌شود.

## الگوی state

الگوی طراحی State به ما این امکان را می‌دهد که حالت داخلی یک شیء را تغییر دهیم و در نتیجه رفتار آن تغییر کند. این الگو برای زمانی مناسب است که رفتار یک شیء به حالت داخلی آن بستگی داشته باشد و بخواهیم بین چندین حالت مختلف سوئیچ کنیم.

استاندار می‌تواند وضعیت مسیرها (یال‌ها) را بین دو حالت یک‌طرفه و دو‌طرفه تغییر دهد. برای مدیریت این تغییر وضعیت‌ها، از الگوی State استفاده می‌کنیم.
پیاده‌سازی:

رابط RouteState: این اینترفیس یک متد setRoutes تعریف می‌کند که برای تنظیم حالت مسیرها به کار می‌رود.

کلاس OneWayState: این کلاس پیاده‌سازی وضعیت یک‌طرفه است. با فراخوانی متد setRoutes، همه‌ی مسیرها به یک‌طرفه تغییر می‌کنند.

 کلاس TwoWayState: این کلاس پیاده‌سازی وضعیت دو‌طرفه است. با فراخوانی متد setRoutes، همه‌ی مسیرها به دو‌طرفه تغییر می‌کنند.
 
 کلاس Governor: این کلاس نقش "استاندار" را ایفا می‌کند که می‌تواند وضعیت مسیرها را تغییر دهد. این کلاس یک نمونه از RouteState را نگه می‌دارد و با فراخوانی متد setRouteState، می‌تواند وضعیت فعلی مسیرها را تغییر دهد.

## مزایای استفاده از این الگوها:

انعطاف‌پذیری: با استفاده از الگوی Strategy، می‌توان به سادگی استراتژی‌های جدیدی برای محاسبه زمان سفر اضافه کرد، بدون اینکه نیازی به تغییر در کلاس‌های دیگر باشد.
کاهش پیچیدگی: الگوی State کمک می‌کند که مدیریت تغییرات در حالت‌های مختلف سیستم (مثلاً تغییر حالت مسیرها) به راحتی و بدون پیچیدگی اضافی انجام شود. و از if و switch های پیچیده جلوگیری می‌کند.
قابلیت نگهداری و توسعه: هر یک از این الگوها به طور جداگانه در کلاس‌های مستقل پیاده‌سازی شده‌اند، که این موضوع به نگهداری و گسترش کد در آینده کمک می‌کند.

## TDD

برای توسعه‌ی کد این سامانه از TDD استفاده کرده‌ایم. به این صورت که برای هر مورد از خواسته‌های مسئله، ابتدا یک تست برای آن نوشتیم و سپس پیاده سازی را طوری انجام دادیم که بالاخره آن تست پاس شود. برای مواردی مثل مقایسه‌ی اتوبوس و قطار، و مسیریابی بدون گذشتن از یک شهر خاص، وقتی که تست اول پاس شد، تست‌های دیگری را هم اضافه کردیم تا حالت‌های مختلف این فیچر‌ها را تست کنیم. مثلا ممکن است بین دو شهر قطار سریع تر باشد یا اتوبوس سریع‌تر باشد. همچنین ممکن بود مسیریابی بین دو شهر ممکن یا ناممکن باشد. بنابراین نیاز داشتیم که تمام این حالت‌ها را تست کنیم.

![image](https://github.com/user-attachments/assets/562ce955-2603-494f-a7f8-0c2dd884152a)

![image](https://github.com/user-attachments/assets/d5d00b85-861c-4ed8-abb0-f461a1ded172)

![image](https://github.com/user-attachments/assets/cbd83483-f296-4c5c-831b-93912d3287e8)

در این عکس‌ها روال کار را برای یک تست نشان داده‌ایم:‌ابتدا تست نوشته می‌شود ولی خطای کامپایل دارد. بعد از تعریف تابع و گذاشتن return value در آن، به خطای assertion می‌خوریم. با درست کردن پیاده‌سازی داخل تابع بالاخره تست پاس می‌شود و می‌توانیم به سراغ مورد بعدی برویم. این کار را برای تمام خواسته‌های مسئله انجام داده‌ایم.

![image](https://github.com/user-attachments/assets/297529f6-5d8f-4b01-a9a8-1eb70a3f1a99)

![image](https://github.com/user-attachments/assets/f26a8737-5ee6-435e-b08a-cf9f9793a170)

![image](https://github.com/user-attachments/assets/10a8d568-b7b7-462e-9286-a794d10d688f)

روالی که مشخص کردیم در این عکس‌ها هم دیده می‌شود. می‌توانید تست‌های هر بخش را در کامیت همان بخش ببینید. همچنین می‌توانید تمام تست‌ها را در فایل تست ببینید.

</div>

فایل اول:
# `parser`
## الگوی facade:

کلاس `Parser` در سازنده خود کار زیادی انجام می‌دهد. می‌توان یک کلاس `ParserInitializer` ایجاد کرد که وظیفه راه‌اندازی کلاس `Parser` را بر عهده بگیرد. به این ترتیب، کلاس `Parser` فقط نیاز دارد با کلاس `ParserInitializer` ارتباط برقرار کند، که به عنوان یک نمایش برای فرآیند راه‌اندازی عمل می‌کند.

## الگوی State/Strategy Pattern:

متد `startParse` شامل یک عبارت `switch` است که رفتار متد را بر اساس `currentAction.action` تغییر می‌دهد. این یک نامزد عالی برای الگوی وضعیت یا استراتژی است. می‌توان یک رابط `ActionStrategy` با یک متد `executeAction()` ایجاد کرد. سپس، برای هر مورد در عبارت `switch،` یک کلاس ایجاد می‌کنیم که `ActionStrategy` را پیاده‌سازی می‌کند.


## الگوی Separate Query From Modifier:

متد `startParse` هم وضعیت شیء `Parser `را تغییر می‌دهد و هم یک نتیجه را برمی‌گرداند. ما می‌توان این دو وظیفه را در متدهای مختلف جدا کرد.


## دیگر الگوها:
الگوی Extract Method:

متد `startParse` بسیار طولانی است. می‌توان بخش‌هایی از آن را در متدهای جداگانه استخراج کرد تا خوانایی و قابلیت نگهداری را بهبود بخشد.



فایل دوم:
# `CodeGenerator`
## الگوی State/Strategy Pattern:

می‌توان از یک نقشه برای جایگزینی عبارت `switch` استفاده کرد، که یک شکل از الگوی استراتژی است.


## الگوی Separate Query From Modifier:



متد pid هم وضعیت `symbolStack` را تغییر می‌دهد و هم `symbolTable` را پرس و جو می‌کند. می‌توان این دو را در دو متد جداگانه جدا کرد.

## دیگر الگوها:

الگوی Replace Nested Conditional with Guard Clauses:

عبارت `if` می‌تواند با یک شرط محافظ جایگزین شود تا کد قابل خواندن‌تر شود.

الگوی Replace Exception with Test:

به جای گرفتن یک استثنا، می‌توان بررسی کرد که آیا نماد در `symbolTable` قبل از دسترسی به آن وجود دارد.


<div dir="rtl">

# سوالات README


## سوال ۱
> الگوهای سازنده (Creational Patterns): این الگوها با فرایند ایجاد اشیا سروکار دارند و راهکارهایی برای جدا کردن فرآیند ساخت اشیا از کلاس‌های استفاده‌کننده ارائه می‌دهند تا وابستگی به پیاده‌سازی‌های خاص کاهش یابد.

> الگوهای ساختاری (Structural Patterns): این الگوها به نحوه ترکیب و تشکیل اشیا و کلاس‌ها برای ایجاد ساختارهای بزرگتر و پیچیده‌تر می‌پردازند، با هدف بهبود انعطاف‌پذیری و کارآیی در ساختار سیستم.

> الگوهای رفتاری (Behavioral Patterns): این الگوها بر تعاملات و مسئولیت‌های بین اشیا و کلاس‌ها تمرکز دارند و راهکارهایی برای مدیریت پیچیدگی‌های ارتباطی و نحوه رفتار سیستم ارائه می‌دهند.


## سوال ۲

> الگو‌های فاز اول از دسته سوم هستند زیرا با مسئولیت بین اشیا سر و کار داریم.


## سوال ۳ 

> برای این کار از الگوی state استفاده می‌کنیم. این الگو مناسب زمانی است که می‌خواهیم یک آبجکت رفتارش را با توجه به حالتی که در آن قرار دارد تغییر دهد. پس با استفاده از دو state برای حالت‌های یک‌طرفه و دو طرفه، امکان رفتن از یک راس به راس دیگر در گراف مشخص می‌شود و می‌توانیم مسیریابی را انجام دهیم.

## سوال ۴

> Single Responsibility Principle (SRP): الگوی Singleton ممکن است این اصل را نقض کند، زیرا علاوه بر وظیفه اصلی کلاس (که می‌تواند ایجاد یک شیء خاص باشد)، مدیریت چرخه عمر آن شیء (مانند ایجاد و دسترسی به تنها نمونه) را نیز بر عهده دارد.

> Open/Closed Principle (OCP): الگوی Singleton معمولاً این اصل را نقض می‌کند، زیرا برای تغییر رفتار یا گسترش عملکرد Singleton، نیاز به تغییر در کد اصلی کلاس است که خلاف باز بودن برای توسعه و بسته بودن برای تغییر است.

> Liskov Substitution Principle (LSP): این اصل معمولاً توسط Singleton نقض نمی‌شود، مگر اینکه پیاده‌سازی‌های خاص Singleton مانع از جایگزینی شیء Singleton با نوع دیگری از آن کلاس شوند.

> Interface Segregation Principle (ISP): الگوی Singleton ذاتاً با این اصل تداخلی ندارد، زیرا معمولاً شامل چندین رابط نیست؛ اما اگر Singleton دارای رابط‌های متعدد با وظایف مختلف باشد، ممکن است نیاز به جداسازی رابط‌ها باشد.

> Dependency Inversion Principle (DIP): الگوی Singleton این اصل را نقض می‌کند، زیرا وابستگی‌های مستقیم به کلاس Singleton ایجاد می‌کند و وابستگی به جزئیات (پیاده‌سازی خاص Singleton) را جایگزین وابستگی به انتزاع (رابط یا کلاس‌های پایه) می‌کند.


## سوال ۵

> کد تمیز: کدی است که خوانا، ساده، سازمان‌یافته و بدون ابهام است، به طوری که به راحتی قابل درک و نگهداری باشد.

> بدهی فنی: مشکلات و نقص‌های فنی ناشی از تصمیمات توسعه سریع یا نادرست که در آینده نیاز به اصلاح یا بازنگری دارند، شبیه به بدهی مالی که باید بازپرداخت شود.

> بوی بد: نشانه‌های قابل تشخیص در کد که به مشکلات احتمالی در طراحی، سازماندهی یا عملکرد کد اشاره دارند و ممکن است نیاز به بهبود داشته باشند.

## سوال ۶

> Bloaters: این دسته شامل بوی بدهایی است که ناشی از رشد بیش از حد اجزای کد (مانند کلاس‌ها، متدها یا پارامترها) هستند و منجر به پیچیدگی و دشواری در نگهداری می‌شوند، مانند متدهای طولانی یا کلاس‌های بزرگ.

> ویژگی‌های شیء (Object-Orientation Abusers): این دسته مربوط به سوءاستفاده یا عدم استفاده مناسب از اصول شیءگرایی است، مانند استفاده نادرست از ارث‌بری یا پیاده‌سازی نادرست انتزاع‌ها که باعث کاهش انعطاف‌پذیری و قابلیت استفاده مجدد می‌شود.

> پیچیدگی (Change Preventers): این بوهای بد کد به تغییرات آینده آسیب می‌زنند و شامل کدهایی هستند که تغییر یا گسترش آنها سخت و خطرناک است، مانند وابستگی‌های چندگانه یا داده‌های منتشر شده در کلاس‌های مختلف.

> Dispensables: این دسته شامل اجزایی است که وجود آنها ضروری نیست و می‌توان آنها را حذف کرد، مانند کدهای مرده، تکراری یا نظرات غیرضروری که تنها باعث گیج شدن خواننده می‌شوند.

> Couplers: این بوهای بد ناشی از وابستگی‌های بیش از حد بین کلاس‌ها و ماژول‌ها هستند که منجر به کدهای سخت نگهدار و ضعیف در برابر تغییرات می‌شوند، مانند کلاس‌های وابسته به پیاده‌سازی یکدیگر به جای استفاده از انتزاع.


## سوال ۷

> Lazy Class جزو دسته Dispensables است.

> Inline Class (درون‌خطی‌کردن کلاس): اگر کلاس Lazy بسیار کوچک و وظایفش را به درستی انجام نمی‌دهد، می‌توان کد آن را به کلاس والد یا کلاس دیگری که از آن استفاده می‌کند منتقل کرد و خود کلاس را حذف نمود.

> Collapse Hierarchy (فروپاشی سلسله‌مراتب): اگر کلاس Lazy تنها یک زیرکلاس یا یک والد دارد و کار اضافی یا مهمی انجام نمی‌دهد، می‌توان سلسله‌مراتب را فروپاشید و تمام وظایف را به کلاس دیگر منتقل کرد.

## سوال ۸

> کلاس DependencyEdge از نوع `Data Class` است.

> تابع getEdgeType در کلاس بالا هیچ کاربردی ندارد و `Dead Code` است.

> حجم زیادی `Comments` در کل پروژه قرار دارد.

> انواع `Long Method` با طول (بیش از ۶۰ خط) در کد وجود دارد.

> تعداد زیادی `Switch Statements` روی فیلد currentNode.getNodeName() وجود دارد.

> در مواقع زیادی تعدادی فیلد مثل  completeClass, className باهم تکرار شده و `Data Clumps` می‌سازند.

> طول برخی کلاس‌ها مثل  Phase1CodeGenerator زیاد است و `Large Class` ساخته است.

> توابع زیادی در کلاس Phase1CodeGenerator مثل generateOneUnionUsage وجود دارند که بهتر است به کلاس CompleteClass منتقل شده تا از `Feature Envy` جلوگیری شود.

> دو تابع ClassConstructor و ClassMethod باهم تعدادی `Duplicate Code` دارند.

> فیلد سراسری documentFactory در Main تنها در صورت خاصی استفاده خواهد شد که از آن یک `Primitive Obsession` خواهد ساخت.


## سوال ۹

> پلاگین Formatter ابزاری است که برای خودکارسازی فرآیند فرمت کردن کدها به کار می‌رود. این پلاگین با اعمال استانداردهای مشخصی بر روی ساختار کد، اطمینان حاصل می‌کند که کدهای نوشته شده در یک پروژه به شکل یکسان و قابل خواندن فرمت شده‌اند. از جمله وظایف این پلاگین‌ها می‌توان به مرتب‌سازی فاصله‌ها (indentation)، حذف فضاهای اضافی، یکسان‌سازی استفاده از نقل‌قول‌ها، و قالب‌بندی خطوط کد اشاره کرد.

> بازآرایی کد فرآیندی است که طی آن کد بهبود یافته و ساختاردهی مجدد می‌شود تا قابل نگهداری و توسعه باشد، بدون تغییر در عملکرد اصلی کد. یکی از اولین قدم‌ها در بازآرایی، اطمینان از درست فرمت بودن کد است. Formatter به عنوان یک ابزار پایه‌ای می‌تواند به آماده‌سازی کد برای بازآرایی کمک کند، زیرا با حذف پیچیدگی‌های ظاهری و ایجاد ساختار یکسان، تحلیل و بهبود کد آسان‌تر می‌شود. در نتیجه، استفاده از Formatter قبل از بازآرایی می‌تواند فرآیند بازآرایی را ساده‌تر و موثرتر کند.

</div>
